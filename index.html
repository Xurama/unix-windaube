<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8">
  <title>Titre de la page</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-+0n0xVW2eSR5OomGNYDnhzAbDsOXxcvSN1TPprVMTNDbiYZCxYbOOl7+AMvyTG2x" crossorigin="anonymous">
  <link href="design.css" rel="stylesheet" type="text/css">
</head>
<body>
    <h1 class="text-center">Projet tutoré. La vache est dans le pré.</h1>
    <h2 class="text-center">PHILIPPE Lucas - BENBETKA Logan</h2>
    <form class="text-center">
        <label for="name">Nombre de piquets ( max : 50 ) </label>
        <input type="text" id="nbPiquets" name="name" required size="10">
        <br><br>
        <div class="container"></div>
        <button type="button" class="btn btn-primary btn-lg text-center" value="Rechercher" id="boutonEnvoi" OnClick="nombrePiquets()">Appuyez</button>
        <button type="button" class="btn btn-primary btn-lg text-center" value="Calcul" id="boutonEnvoiCalcul" OnClick="main()" style="display:none;">Calculez</button>
        <button type="button" class="btn btn-primary btn-lg text-center" value="Reset" id="boutonReset" OnClick="reset()"  style="display:none;">Reset</button>
    </form>

    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.0/jquery.min.js"></script>
    <script type="text/javascript">

        // récupère le nombre de piquets et lance la fonction conditionNombrePiquets
        function nombrePiquets(){
            const nbPiquets = document.getElementById("nbPiquets").value;
            const myBtnSearch = document.getElementById("boutonEnvoi");
            const myBtnCalcul = document.getElementById("boutonEnvoiCalcul");
            conditionNombrePiquets(nbPiquets, myBtnSearch, myBtnCalcul);
        }

        // vérifie si le nombre de piquets n'est pas supérieur a 50 et 
        //passe à la suite du programme
        function conditionNombrePiquets(nbPiquets, myBtnSearch, myBtnCalcul){
            if(nbPiquets>50)
                $(".container").append(
                    "<p> Vous n'avez pas le droit de prendre plus de 50 piquets</p>");
            else{
                $(".container").append(
                    "<div>" + "<p>Donnez les coordonnées ( x et y ) de chaque piquets</p>");
                for(i=0; i<=nbPiquets-1;i++)            
                    $(".container").append(
                        "<div class='marginBottom'> <label " + " for='piquet-" + i + "'>Piquet n°" +
                        (i+1) + " : </label>" +
                        "<input name=arrayX[] placeholder=Coordonnée-X "+ (i+1) + "/>" +
                        "<input class='marginLeft' name=arrayY[] placeholder=Coordonnée-Y "+ 
                        (i+1) + "/>" + "</div>" + "<br>");
                myBtnSearch.style.display = "none";
                myBtnCalcul.style.display = "block";
            }
        }

        // récupère les coordonnées des piquets et lance les calculs via 
        //calculCentreGravite()
        // et calculAppartenancePointPolygone()
        function main(){
            const coordonneeX = document.getElementsByName("arrayX[]");
            const coordonneeY = document.getElementsByName("arrayY[]");
            const nbPiquets = document.getElementById("nbPiquets").value;
            const myBtnCalcul = document.getElementById("boutonEnvoiCalcul");
            let x = [];
            let y = [];
            for(i=0; i<=nbPiquets-1; i++){            
                x[i] = parseFloat(coordonneeX[i].value);
                y[i] = parseFloat(coordonneeY[i].value);
            }
            myBtnCalcul.style.display = "none";
            pointGravite = calculCentreGravite(x, y, nbPiquets);
            calculAppartenancePointPolygone(x, y, nbPiquets, pointGravite);
        }

        //permet de calculer le centre de gravité en fonction de l'aire des piquets
        // c'est pourquoi il lance la fonction calculAire() en premier
        // et il appelle aussi la fonciton affichageAireCentreGravite
        // afin d'afficher les résultats.
        function calculCentreGravite(x, y, nbPiquets){
            aire = calculAire(x, y, nbPiquets);
            let centreDeGraviteX = 0;
            let centreDeGraviteY = 0;
            for(i=0;i<=nbPiquets-1;i++){
                centreDeGraviteX += ( x[i] + x[(i+1)%nbPiquets] ) *
                 ( x[i] * y[(i+1)%nbPiquets] - x[(i+1)%nbPiquets] * y[i] );
                centreDeGraviteY += ( y[i] + y[(i+1)%nbPiquets] ) * ( x[i] *
                 y[(i+1)%nbPiquets] - x[(i+1)%nbPiquets] * y[i] );
            }
            centreDeGraviteX = (1/(6 * aire)) * centreDeGraviteX;
            centreDeGraviteY = (1/(6 * aire)) * centreDeGraviteY;
            pointGravite = affichageAireCentreGravite(centreDeGraviteX, centreDeGraviteY);
            return pointGravite;
        }

        // calcul et retourne l'aire en fonction des coordonnnées des piquets
        function calculAire(x, y, nbPiquets){
            let aire = 0;
            for(i=0;i<=nbPiquets-1;i++)
                aire += x[i] * y[(i+1)%nbPiquets] -  x[(i+1)%nbPiquets] * y[i];
            aire = aire * (1/2);
            return aire;
        }

        // lance l'affichage des résultats de l'aire et du centre de gravité
        // si le centre de gravité ne renvoie pas NaN
        function affichageAireCentreGravite(centreDeGraviteX, centreDeGraviteY){
            let pointGravite = new Boolean("false");
            if(isNaN(centreDeGraviteX)&&isNaN(centreDeGraviteY))
                pointGravite = "true";
            else{
                $(".container").append(
                    "<div class='marginBottom'><p>Aire : ("+ Math.abs(aire) +") </p>" +
                    "<div class='marginBottom'><p>Centre de gravité : ("+ centreDeGraviteX + 
                        ", " + centreDeGraviteY +") </p>"); 
                pointGravite = "false";
            }
            return pointGravite;
        }

        // cette fonction permet de faire le calcul afin de savoir
        // si le point appartient au polygone
        // il vérifie d'abord si le centre de gravité n'a pas renvoyé NaN
        // puis il lance la fonction calculTheta() puis
        // conditionAppartenancePointPolygone()
        function calculAppartenancePointPolygone(x, y, nbPiquets, pointGravite){
            let determinant = determinant2Vecteurs(x, y, nbPiquets);
            let vacheDansEnclos = new Boolean("false");
            let somme=0;
            if(pointGravite==="true")
                $(".container").append(
                    "<div class='marginBottom'>" +
                    "<p>Les piquets ne sont pas donnés dans le bon ordre.</p>"); 
            else{
                theta = calculTheta(x, y, nbPiquets);
                for(i=0;i<=nbPiquets-1;i++){
                    if(determinant<=0)
                        somme[i] += theta;
                    else
                        somme[i] -= theta; 
                }
                conditionAppartenancePointPolygone(somme);
            }
        }

        // cette fonction permet de vérifier si le point appartient
        // bien au polygone
        function conditionAppartenancePointPolygone(somme){
            if(somme==0){
                vacheDansEnclos="false";
                $(".container").append(
                "<div class='marginBottom'><p>Position de la vache : intérieur </p>");  
            }
            else{
                vacheDansEnclos="true";
                $(".container").append(
                "<div class='marginBottom'><p>Position de la vache : extérieur </p>"); 
            } 
        }

        //cette fonction permet de calculer theta
        function calculTheta(x, y, nbPiquets)
        {
            let theta;
            produitScalaire = produitScalaireVecteur(x, y, nbPiquets);
            norme = normeVecteur(x, y, nbPiquets);
            for(i=0;i<=nbPiquets-1;i++)
                theta = Math.acos(produitScalaire[i]/(norme[i]*norme[(i+1)%nbPiquets]));
            return theta;
        }

        // cette fonction permet de calculer le produit scalaire de vecteurs
        function produitScalaireVecteur(x, y, nbPiquets){
            vecteur = coordonneesVecteur(x, y, nbPiquets);
            vecteurX = vecteur[0];
            vecteurY = vecteur[1];
            let produitScalaireVecteur = [];
            for(i=0;i<=nbPiquets-1;i++)
                produitScalaireVecteur[i] = vecteurX[i] * vecteurX[(i+1)%nbPiquets] +
                 vecteurY[i] * vecteurY[(i+1)%nbPiquets];
            return produitScalaireVecteur;
        }

        // cette fonction permet de calculer la norme des vecteurs
        function normeVecteur(x, y, nbPiquets){
            vecteur = coordonneesVecteur(x, y, nbPiquets);
            vecteurX = vecteur[0];
            vecteurY = vecteur[1];
            let normeVecteur = [];
            for(i=0;i<=nbPiquets-1;i++)
                normeVecteur[i] = Math.sqrt((Math.pow(vecteurX[i], 2)) +
                 (Math.pow(vecteurY[i], 2)));
            return normeVecteur;
        }

        //cette fonction permet de calculer le déterminant de 2 vecteurs
        function determinant2Vecteurs(x, y, nbPiquets){
            vecteur = coordonneesVecteur(x, y, nbPiquets);
            vecteurX = vecteur[0];
            vecteurY = vecteur[1];
            let determinantVecteur = [];
            for(i=0;i<=nbPiquets-1;i++)
                determinantVecteur[i] = vecteurX[i] *  vecteurY[(i+1)%nbPiquets] -
                 vecteurY[i] *  vecteurX[(i+1)%nbPiquets];
            return determinantVecteur;
        }

        //cette fonction permet de calculer les coordonnées de vecteurs
        function coordonneesVecteur(x, y, nbPiquets){
            let vecteurX = [];
            let vecteurY = [];
            for(i=0;i<=nbPiquets-1;i++){
                vecteurX[i] = (x[(i+1)%nbPiquets]) - (x[i]); 
                vecteurY[i] = (y[(i+1)%nbPiquets]) - (y[i]);
            }
            return [vecteurX, vecteurY];
        }
    </script>
</body>
</html>